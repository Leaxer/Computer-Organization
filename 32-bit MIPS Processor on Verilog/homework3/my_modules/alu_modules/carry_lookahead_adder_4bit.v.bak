module carry_lookahead_adder_4bit (output [3:0] sum, output c_out, input [3:0] a, input [3:0] b, input c_in);
	wire [3:0] p, g;
	wire [2:0] c;
	and g0(g[0], a[0], b[0]);
	and g1(g[1], a[1], b[1]);
	and g2(g[2], a[2], b[2]);
	and g3(g[3], a[3], b[3]);

	or p0(p[0], a[0], b[0]);
	or p1(p[1], a[1], b[1]);
	or p2(p[2], a[2], b[2]);
	or p3(p[3], a[3], b[3]);
	
	//c0 
	and and1(result1, p[0], c_in);
	or or1(c[0], g[0], result1);

	//c1
	and and2(result2, p[1], result1);
	and and3(result3, p[1], g[0]);
	or or2(orResult1, result2, result3);
	or or3(c[1], g[1], orResult1);
	//c2
	and and4(result4, p[2], result2);
	and and5(result5, p[2], result3);
	and and6(result6, p[2], g[1]);
	or or4(orResult2, result4, result5);
	or or5(orResult3, result6, orResult2);
	or or6(c[2], g[2], orResult3);

	//c3
	and and7(result7, p[3], result4);
	and and8(result8, p[3], result5);
	and and9(result9, p[3], result6);
	and and10(result10, p[3], g[2]);
	or or7(orResult4, result7, result8);
	or or8(orResult5, result9, orResult4);
	or or9(orResult6, result10, orResult5);
	or or10(c_out, g[3], orResult6);
	
	//s0
	xor xor1 (xorResult1, b[0], c_in);
	xor xor2 (sum[0], a[0], xorResult1);

	//s1
	xor xor3 (xorResult2, b[1], c[0]);
	xor xor4 (sum[1], a[1], xorResult2);

	//s2
	xor xor5 (xorResult3, b[2], c[1]);
	xor xor6 (sum[2], a[2], xorResult3);

	//s3
	xor xor7 (xorResult4, b[3], c[2]);
	xor xor8 (sum[3], a[3], xorResult4);
endmodule